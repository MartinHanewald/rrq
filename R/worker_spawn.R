##' Spawn a worker in the background
##'
##' Spawning multiple workers.  If \code{n} is greater than one,
##' multiple workers will be spawned.  This happens in parallel so it
##' does not take n times longer than spawing a single worker.
##'
##' Beware that signals like Ctrl-C passed to \emph{this} R instance
##' can still propagate to the child processes and can result in them
##' dying unexpectedly.  It is probably safer to start processes in a
##' completely separate session.
##'
##' @title Spawn a worker
##' @inheritParams rrq_controller
##' @param n Number of workers to spawn
##' @param logdir Path of a log directory to write to.
##' @param timeout Time to wait for the worker to appear
##' @param time_poll Period to poll for the worker (must be in
##'   seconds)
##' @param path Path to start the worker in.  By default workers will
##'   start in the current working directory, but you can start them
##'   elsewhere by providing a path here.  If the path does not exist,
##'   an error will be thrown.  If \code{n} is greater than 1, all
##'   workers will start in the same working directory.  The
##'   \code{logfile} argument will be interpreted relative to current
##'   working directory (not the worker working directory); use
##'   \code{\link{normalizePath}} to convert into an absolute path
##'   name to prevent this.
##'
##' @param worker_name_base Optional base to construct the worker
##'   names from.  If omitted a random name will be used.
##'
##' @param worker_time_poll Interval that the worker should poll at
##'   (not the same as \code{time_poll}).
##'
##' @param worker_timeout Time before workers should turn off (not the
##'   same as \code{timeout})
##'
##' @param worker_log_path Per-task log directory for workers (not the
##'   same as \code{logdir}, which is for the worker overall).
##'
##' @export
workers_spawn <- function(context, con, n=1, logdir=".",
                          timeout=600, time_poll=1,
                          path=".", worker_name_base=NULL,
                          worker_time_poll=NULL, worker_timeout=NULL,
                          worker_log_path=NULL) {
  rrq_worker <- system.file("rrq_worker", package="rrq")
  env <- paste0("RLIBS=", paste(.libPaths(), collapse=":"),
                'R_TESTS=""')

  worker_names <- sprintf(
    "%s_%d", worker_name_base %||% ids::adjective_animal(), seq_len(n))

  if (!file.exists(logdir)) {
    dir.create(logdir, FALSE, TRUE)
  } else if (!file.info(logdir)$isdir) {
    stop("logdir exists but is not a directory")
  }
  logdir <- normalizePath(logdir, mustWork=TRUE)
  logfile <- file.path(logdir, paste0(worker_names, ".log"))

  if (!is.null(worker_log_path)) {
    dir.create(worker_log_path, FALSE, TRUE)
  }

  assert_integer_like(time_poll)

  key_alive <- rrq_key_worker_alive(context$id)

  args <- c("--context-root", normalizePath(context$root),
            "--context-id", context$id,
            "--redis-host", con$config()$host,
            "--redis-port", con$config()$port,
            "--key-alive", key_alive,
            if (!is.null(worker_time_poll)) "--time-poll", worker_time_poll,
            if (!is.null(worker_timeout)) "--timeout", worker_timeout,
            if (!is.null(worker_log_path)) "--log-path", worker_log_path)

  code <- integer(n)
  with_wd(path, {
    for (i in seq_len(n)) {
      code[[i]] <- system2(rrq_worker,
                           c(args, "--worker-name", worker_names[[i]]),
                           env=env, wait=FALSE,
                           stdout=logfile[[i]], stderr=logfile[[i]])
    }
  })
  if (any(code != 0L)) {
    warning("Error launching script: worker *probably* does not exist")
  }

  workers_wait(con, n, key_alive, timeout, time_poll)
}

##' @export
##' @rdname workers_spawn
##' @param key_alive A key as generated by \code{\link{rrq_key_worker_alive}}
workers_wait <- function(con, n, key_alive, timeout=600, time_poll=1) {
  ret <- rep.int(NA_character_, n)
  t0 <- Sys.time()
  timeout <- as.difftime(timeout, units="secs")

  i <- 1L
  repeat {
    x <- con$BLPOP(key_alive, time_poll)
    if (is.null(x)) {
      message(".", appendLF=FALSE)
      flush.console()
    } else {
      ret[[i]] <- x[[2]]
      if (n > 1L) {
        message(sprintf("new worker: %s (%d / %d)", x[[2]], i, n))
      } else {
        message(sprintf("new worker: %s", x[[2]]))
      }
      i <- i + 1
    }
    if (!any(is.na(ret))) {
      break
    }
    if (Sys.time() - t0 > timeout) {
      ## TODO: Better recover here.  Ideally we'd stop any workers
      ## that *are* running, and provide data from the log files.
      stop(sprintf("%d / %d workers not identified in time",
                   sum(is.na(ret)), n))
    }
  }

  ret
}
