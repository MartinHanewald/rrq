##' Spawn a worker in the background
##'
##' Spawning multiple workers.  If \code{n} is greater than one,
##' multiple workers will be spawned.  This happens in parallel so it
##' does not take n times longer than spawing a single worker.
##'
##' Beware that signals like Ctrl-C passed to \emph{this} R instance
##' can still propagate to the child processes and can result in them
##' dying unexpectedly.  It is probably safer to start processes in a
##' completely separate session.
##'
##' @title Spawn a worker
##'
##' @param obj An \code{rrq_controller} object
##'
##' @param n Number of workers to spawn
##'
##' @param logdir Path of a log directory to write to.  This will be
##'   interpreted relative to the context root.
##'
##' @param timeout Time to wait for workers to appear
##'
##' @param worker_config Name of the configuration to use.  By default
##'   the \code{"localhost"} configuration is used, which duplicates
##'   the redis information from the local configuration but otherwise
##'   uses the defaults.
##'
##' @param worker_name_base Optional base to construct the worker
##'   names from.  If omitted a random name will be used.
##'
##' @param path Path to start the worker in.  By default workers will
##'   start in the current working directory, but you can start them
##'   elsewhere by providing a path here.  If the path does not exist,
##'   an error will be thrown.  If \code{n} is greater than 1, all
##'   workers will start in the same working directory.  The
##'   \code{logfile} argument will be interpreted relative to current
##'   working directory (not the worker working directory); use
##'   \code{\link{normalizePath}} to convert into an absolute path
##'   name to prevent this.
##'
##' @param progress Show a progress bar while waiting for workers
##'   (when \code{timeout} is at least 0)
##'
##' @export
workers_spawn <- function(obj, n = 1, logdir = "worker_logs",
                          timeout = 600, worker_config = "localhost",
                          worker_name_base = NULL, path = NULL,
                          progress = TRUE) {
  assert_inherits(obj, "rrq_controller")
  if (!obj$db$exists(worker_config, "worker_config")) {
    stop(sprintf("worker config '%s' does not exist", worker_config))
  }
  if (!is.null(path)) {
    stop("FIXME")
  }

  rrq_worker <- system.file("rrq_worker", package = "rrq")
  env <- paste0("RLIBS=", paste(.libPaths(), collapse = ":"),
                ' R_TESTS=""')
  worker_name_base <- worker_name_base %||% ids::adjective_animal()
  worker_names <- sprintf("%s_%d", worker_name_base, seq_len(n))

  logdir_abs <- file.path(obj$context$root$path, logdir)
  if (!file.exists(logdir_abs)) {
    dir.create(logdir_abs, FALSE, TRUE)
  }
  obj$context$db$mset(worker_names, file.path(logdir, worker_names), "log_path")
  logfile <- file.path(logdir_abs, worker_names)

  root <- normalizePath(obj$context$root$path)
  context_id <- obj$context$id
  key_alive <- rrq_key_worker_alive(context_id)

  if (progress) {
    message(sprintf("Spawning %d %s with prefix %s",
                    n, ngettext(n, "worker", "workers"), worker_name_base))
  }
  code <- integer(n)
  ## TODO: path is never used in the package
  ## with_wd(path, {
  for (i in seq_len(n)) {
    args <- c(root, context_id, worker_config, worker_names[[i]], key_alive)
    code[[i]] <- system2(rrq_worker, args, env = env, wait = FALSE,
                         stdout = logfile[[i]], stderr = logfile[[i]])
  }
  ## })
  if (any(code != 0L)) {
    warning("Error launching script: worker *probably* does not exist")
  }

  if (timeout > 0) {
    time_poll <- 1
    workers_wait(obj$con, n, key_alive, timeout, time_poll, progress)
  } else {
    worker_names
  }
}

##' @export
##' @rdname workers_spawn
##' @param key_alive A key as generated by \code{\link{rrq_key_worker_alive}}
workers_wait <- function(con, n, key_alive, timeout = 600, time_poll = 1,
                         progress = TRUE) {
  p <- queuer:::progress(total = n, show = progress)
  time_poll <- min(time_poll, timeout)
  times_up <- time_checker(timeout)
  i <- 1L
  ret <- rep.int(NA_character_, n)
  repeat {
    x <- con$BLPOP(key_alive, time_poll)
    if (is.null(x)) {
      p(0)
    } else {
      ret[[i]] <- x[[2]]
      p(1)
      i <- i + 1L
    }
    if (!any(is.na(ret))) {
      break
    }
    if (times_up()) {
      if (progress) {
        message()
      }
      ## TODO: Better recover here.  Ideally we'd stop any workers
      ## that *are* running, and provide data from the log files.
      stop(sprintf("%d / %d workers not identified in time",
                   sum(is.na(ret)), n), call. = FALSE)
    }
  }
  ret
}
